/* vim:ts=4
 *
 * Copyleft 2008…2011  Michał Gawron
 * Marduk Unix Labs, http://mulabs.org/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for more information on licensing.
 */

#ifndef HARUHI__PLUGINS__YUKI__PART_H__INCLUDED
#define HARUHI__PLUGINS__YUKI__PART_H__INCLUDED

// Standard:
#include <cstddef>
#include <list>

// Haruhi:
#include <haruhi/config/all.h>
#include <haruhi/dsp/wavetable.h>
#include <haruhi/dsp/parametric_wave.h>
#include <haruhi/graph/event.h>
#include <haruhi/graph/event_port.h>
#include <haruhi/graph/audio_buffer.h>
#include <haruhi/graph/port_group.h>
#include <haruhi/utility/atomic.h>
#include <haruhi/utility/work_performer.h>
#include <haruhi/utility/numeric.h>

// Local:
#include "has_widget.h"
#include "has_id.h"
#include "has_plugin.h"
#include "params.h"


namespace Yuki {

namespace DSP = Haruhi::DSP;

class PartWidget;
class PartManager;
class VoiceManager;

class Part:
	public HasWidget<PartWidget>,
	public HasID
{
	friend class PartWidget;

	class UpdateWavetableWorkUnit: public WorkPerformer::Unit
	{
	  public:
		/**
		 * \param	wavetable is the wavetable to update.
		 */
		UpdateWavetableWorkUnit (Part*);

		/**
		 * Prepare work unit for another work.
		 * \param	base_wave Base wave for computation. It's cloned inside.
		 * \param	modulator_wave Modulator wave. It's cloned.
		 * \param	wavetable Target wavetable object.
		 * \param	serial Update request ID.
		 */
		void
		reset (DSP::Wavetable* wavetable, unsigned int serial);

		/**
		 * Recompute wavetable.
		 */
		void
		execute();

		/**
		 * Cancel computations in the middle as soon as possible.
		 */
		void
		cancel();

		/**
		 * Return serial.
		 */
		unsigned int
		serial() const;

	  private:
		/**
		 * Return true if the unit was marked as cancelled
		 * with cancel() method.
		 */
		bool
		is_cancelled() const;

	  private:
		Part*					_part;
		DSP::Wavetable*			_wavetable;
		unsigned int			_serial;
		Atomic<bool>			_is_cancelled;
	};

  public:
	/**
	 * Contains Haruhi ports created for the part.
	 */
	class PartPorts: public HasPlugin
	{
	  public:
		PartPorts (Plugin* plugin, unsigned int part_id);

		~PartPorts();

	  public:
		// Waveform ports:
		Haruhi::EventPort*	wave_shape;
		Haruhi::EventPort*	modulator_amplitude;
		Haruhi::EventPort*	modulator_index;
		Haruhi::EventPort*	modulator_shape;

		// Part ports:
		Haruhi::EventPort*	volume;
		Haruhi::EventPort*	portamento_time;
		Haruhi::EventPort*	phase;

		// Polyphonic-input ports:
		Haruhi::EventPort*	amplitude;
		Haruhi::EventPort*	frequency;
		Haruhi::EventPort*	panorama;
		Haruhi::EventPort*	detune;
		Haruhi::EventPort*	pitchbend;
		Haruhi::EventPort*	velocity_sens;
		Haruhi::EventPort*	unison_index;
		Haruhi::EventPort*	unison_spread;
		Haruhi::EventPort*	unison_init;
		Haruhi::EventPort*	unison_noise;
		Haruhi::EventPort*	noise_level;

	  private:
		Haruhi::PortGroup*	_port_group;
	};

  public:
	Part (PartManager*, WorkPerformer* rendering_work_performer, Params::Main* main_params, unsigned int id);

	~Part();

	/**
	 * Return PartManager that manages this Part.
	 */
	PartManager*
	part_manager() const;

	/**
	 * Return part params.
	 */
	Params::Part*
	part_params();

	/**
	 * Return voice params template.
	 */
	Params::Voice*
	voice_params();

	/**
	 * Return ports list created by the part.
	 */
	PartPorts*
	ports();

	/**
	 * Handle voice input event.
	 * Pass it to the voice manager if conditions are met.
	 */
	void
	handle_voice_event (Haruhi::VoiceEvent const*);

	/**
	 * Process events.
	 */
	void
	process();

	/**
	 * Panic all voices.
	 */
	void
	panic();

	/**
	 * Resize buffers, etc.
	 */
	void
	graph_updated();

	/**
	 * Params has been changed and update is needed.
	 */
	void
	params_updated();

	/**
	 * Update wavetable according to new parameters.
	 * Switch double-buffered wavetables.
	 * Do not propagate new wavetable to VoiceManager
	 */
	void
	update_wavetable();

	/**
	 * Start voices rendering.
	 */
	void
	render();

	/**
	 * Wait until voice rendering is done.
	 */
	void
	wait_for_render();

	/**
	 * Mix rendered voices into given buffers.
	 */
	void
	mix_rendering_result (Haruhi::AudioBuffer*, Haruhi::AudioBuffer*);

	/**
	 * Return voices number generated by this part.
	 */
	unsigned int
	voices_number() const;

	/**
	 * Return currently selected base wave object.
	 */
	DSP::ParametricWave*
	base_wave() const;

	/**
	 * Return currently selected modulator wave object.
	 */
	DSP::ParametricWave*
	modulator_wave() const;

	/**
	 * Allocate Wave* that incorporates harmonics and modulation
	 * taken from parameters object at the time of the call.
	 * Must be deleted after use.
	 * \threadsafe
	 */
	DSP::Wave*
	final_wave() const;

  private:
	/**
	 * Check if work unit for wavetable update
	 * is finished. Ensure that update actually
	 * takes place if needed.
	 *
	 * Called on each processing round.
	 */
	void
	check_wavetable_update_process();

	/**
	 * Notify that new wavetable with given serial number
	 * has been computed.
	 *
	 * Switches wavetables and propagates notification
	 * to the voice manager.
	 *
	 * \entry	UpdateWavetableWorkUnit (WorkPerformer)
	 */
	void
	wavetable_computed (unsigned int serial);

  private:
	PartManager*				_part_manager;
	VoiceManager*				_voice_manager;
	Params::Part				_part_params;
	Params::Voice				_voice_params;
	DSP::ParametricWave*		_base_waves[9];
	DSP::ParametricWave*		_modulator_waves[4];
	DSP::Wavetable*				_wavetables[2];
	Atomic<bool>				_switch_wavetables;
	Atomic<unsigned int>		_wt_update_request;
	Atomic<unsigned int>		_wt_serial;
	UpdateWavetableWorkUnit*	_wt_wu;
	bool						_wt_wu_ever_started;
	PartPorts					_ports;
};


typedef std::list<Part*>  Parts;


inline void
Part::UpdateWavetableWorkUnit::cancel()
{
	_is_cancelled.store (true);
}


inline unsigned int
Part::UpdateWavetableWorkUnit::serial() const
{
	return _serial;
}


inline bool
Part::UpdateWavetableWorkUnit::is_cancelled() const
{
	return _is_cancelled.load();
}


inline PartManager*
Part::part_manager() const
{
	return _part_manager;
}


inline Params::Part*
Part::part_params()
{
	return &_part_params;
}


inline Params::Voice*
Part::voice_params()
{
	return &_voice_params;
}


inline Part::PartPorts*
Part::ports()
{
	return &_ports;
}


inline DSP::ParametricWave*
Part::base_wave() const
{
	return _base_waves[bound (_part_params.wave_type.get(), 0u, static_cast<unsigned int> (ARRAY_SIZE (_base_waves) - 1))];
}


inline DSP::ParametricWave*
Part::modulator_wave() const
{
	return _modulator_waves[bound (_part_params.modulator_wave_type.get(), 0u, static_cast<unsigned int> (ARRAY_SIZE (_modulator_waves) - 1))];
}

} // namespace Yuki

#endif

